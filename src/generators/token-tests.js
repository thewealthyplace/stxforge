function generateTokenTests(config) {
  const { name, symbol, decimals, supply, mintable, burnable, capped, maxSupply, contractName } = config;

  return `import { describe, it, expect, beforeEach } from 'vitest';
import { Clarinet, Tx, Chain, Account, types } from '@hirosystems/clarinet-sdk';

// Test suite for ${name} (${symbol}) — SIP-010 Token
// Generated by stxforge

describe('${contractName} — SIP-010 Token', () => {
  let chain: Chain;
  let accounts: Map<string, Account>;
  let deployer: Account;
  let wallet1: Account;
  let wallet2: Account;

  beforeEach(async () => {
    ({ chain, accounts } = await Clarinet.loadProject('./'));
    deployer = accounts.get('deployer')!;
    wallet1  = accounts.get('wallet_1')!;
    wallet2  = accounts.get('wallet_2')!;
  });

  // ── Read-Only: get-name ──────────────────────────────────────────────
  describe('get-name', () => {
    it('returns the correct token name', async () => {
      const result = chain.callReadOnlyFn(
        '${contractName}', 'get-name', [], deployer.address
      );
      result.result.expectOk().expectAscii('${name}');
    });
  });

  // ── Read-Only: get-symbol ────────────────────────────────────────────
  describe('get-symbol', () => {
    it('returns the correct token symbol', async () => {
      const result = chain.callReadOnlyFn(
        '${contractName}', 'get-symbol', [], deployer.address
      );
      result.result.expectOk().expectAscii('${symbol}');
    });
  });

  // ── Read-Only: get-decimals ──────────────────────────────────────────
  describe('get-decimals', () => {
    it('returns ${decimals} decimals', async () => {
      const result = chain.callReadOnlyFn(
        '${contractName}', 'get-decimals', [], deployer.address
      );
      result.result.expectOk().expectUint(${decimals});
    });
  });

  // ── Read-Only: get-total-supply ──────────────────────────────────────
  describe('get-total-supply', () => {
    it('returns the correct initial total supply', async () => {
      const result = chain.callReadOnlyFn(
        '${contractName}', 'get-total-supply', [], deployer.address
      );
      result.result.expectOk().expectUint(${supply});
    });
  });

  // ── Read-Only: get-balance ───────────────────────────────────────────
  describe('get-balance', () => {
    it('deployer holds the full initial supply', async () => {
      const result = chain.callReadOnlyFn(
        '${contractName}', 'get-balance',
        [types.principal(deployer.address)], deployer.address
      );
      result.result.expectOk().expectUint(${supply});
    });

    it('new wallet starts with zero balance', async () => {
      const result = chain.callReadOnlyFn(
        '${contractName}', 'get-balance',
        [types.principal(wallet1.address)], deployer.address
      );
      result.result.expectOk().expectUint(0);
    });
  });

  // ── Transfer ─────────────────────────────────────────────────────────
  describe('transfer', () => {
    it('transfers tokens between accounts', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'transfer', [
          types.uint(1000),
          types.principal(deployer.address),
          types.principal(wallet1.address),
          types.none(),
        ], deployer.address),
      ]);
      block.receipts[0].result.expectOk().expectBool(true);

      const balance = chain.callReadOnlyFn(
        '${contractName}', 'get-balance',
        [types.principal(wallet1.address)], deployer.address
      );
      balance.result.expectOk().expectUint(1000);
    });

    it('rejects transfer from non-owner (sender != tx-sender)', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'transfer', [
          types.uint(1000),
          types.principal(deployer.address),
          types.principal(wallet2.address),
          types.none(),
        ], wallet1.address), // wallet1 tries to move deployer's tokens
      ]);
      block.receipts[0].result.expectErr().expectUint(101);
    });

    it('rejects zero-amount transfer', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'transfer', [
          types.uint(0),
          types.principal(deployer.address),
          types.principal(wallet1.address),
          types.none(),
        ], deployer.address),
      ]);
      block.receipts[0].result.expectErr().expectUint(103);
    });

    it('rejects transfer to self', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'transfer', [
          types.uint(100),
          types.principal(deployer.address),
          types.principal(deployer.address),
          types.none(),
        ], deployer.address),
      ]);
      block.receipts[0].result.expectErr().expectUint(104);
    });

    it('rejects transfer with insufficient balance', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'transfer', [
          types.uint(999999999999999),
          types.principal(wallet1.address),
          types.principal(wallet2.address),
          types.none(),
        ], wallet1.address),
      ]);
      block.receipts[0].result.expectErr();
    });

    it('prints memo when provided', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'transfer', [
          types.uint(100),
          types.principal(deployer.address),
          types.principal(wallet1.address),
          types.some(types.buff(Buffer.from('payment', 'utf8'))),
        ], deployer.address),
      ]);
      block.receipts[0].result.expectOk().expectBool(true);
    });
  });

  // ── set-token-uri ─────────────────────────────────────────────────────
  describe('set-token-uri', () => {
    it('owner can set token URI', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'set-token-uri', [
          types.some(types.utf8('https://example.com/token-metadata.json')),
        ], deployer.address),
      ]);
      block.receipts[0].result.expectOk().expectBool(true);
    });

    it('non-owner cannot set token URI', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'set-token-uri', [
          types.some(types.utf8('https://evil.com')),
        ], wallet1.address),
      ]);
      block.receipts[0].result.expectErr().expectUint(100);
    });
  });
${mintable ? `
  // ── Mint ──────────────────────────────────────────────────────────────
  describe('mint', () => {
    it('minter can mint tokens to a recipient', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'mint', [
          types.uint(5000),
          types.principal(wallet1.address),
        ], deployer.address),
      ]);
      block.receipts[0].result.expectOk();

      const balance = chain.callReadOnlyFn(
        '${contractName}', 'get-balance',
        [types.principal(wallet1.address)], deployer.address
      );
      balance.result.expectOk().expectUint(5000);
    });

    it('non-minter cannot mint', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'mint', [
          types.uint(5000),
          types.principal(wallet1.address),
        ], wallet1.address),
      ]);
      block.receipts[0].result.expectErr().expectUint(100);
    });

    it('owner can change minter role', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'set-minter', [
          types.principal(wallet1.address),
        ], deployer.address),
      ]);
      block.receipts[0].result.expectOk().expectBool(true);
    });
  });
` : ''}${burnable ? `
  // ── Burn ──────────────────────────────────────────────────────────────
  describe('burn', () => {
    it('token owner can burn their own tokens', async () => {
      const supplyBefore = chain.callReadOnlyFn(
        '${contractName}', 'get-total-supply', [], deployer.address
      );

      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'burn', [
          types.uint(1000),
          types.principal(deployer.address),
        ], deployer.address),
      ]);
      block.receipts[0].result.expectOk();

      const supplyAfter = chain.callReadOnlyFn(
        '${contractName}', 'get-total-supply', [], deployer.address
      );
      const before = Number(supplyBefore.result.expectOk().expectUint());
      const after  = Number(supplyAfter.result.expectOk().expectUint());
      expect(after).toBe(before - 1000);
    });

    it('non-owner cannot burn another wallet tokens', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'burn', [
          types.uint(100),
          types.principal(deployer.address),
        ], wallet1.address),
      ]);
      block.receipts[0].result.expectErr().expectUint(101);
    });
  });
` : ''}${capped ? `
  // ── Max Supply Cap ────────────────────────────────────────────────────
  describe('max supply cap', () => {
    it('cannot mint beyond the max supply', async () => {
      const block = chain.mineBlock([
        Tx.contractCall('${contractName}', 'mint', [
          types.uint(${maxSupply} + 1),
          types.principal(wallet1.address),
        ], deployer.address),
      ]);
      block.receipts[0].result.expectErr().expectUint(105);
    });
  });
` : ''}
  // ── get-token-uri ─────────────────────────────────────────────────────
  describe('get-token-uri', () => {
    it('returns none by default', async () => {
      const result = chain.callReadOnlyFn(
        '${contractName}', 'get-token-uri', [], deployer.address
      );
      result.result.expectOk().expectNone();
    });
  });
});
`;
}

module.exports = { generateTokenTests };
